## Core Java Syllabus - Brief Guide

### Fundamentals
- JVM
   - A runtime environment that executes Java bytecode. It provides memory management, garbage collection, and security features. The JVM is platform-specific but allows Java programs to run on any operating system.
- Bytecode
   - Intermediate code generated by the Java compiler (.class files). It's platform-independent and executed by the JVM. Bytecode is more efficient than interpreted languages but slower than native machine code.
- Platform Independence
   - Java's "write once, run anywhere" principle. Source code compiles to bytecode that runs on any JVM, regardless of the underlying operating system or hardware architecture.
- Data types, variables, control flow, arrays
- Packages
   - Namespace mechanism to organize classes and avoid naming conflicts. Use package declarations at the top of source files. Import classes using import statements or fully qualified names.
- Access Modifiers
   - Control visibility of classes, methods, and fields. Four levels: public (everywhere), protected (package + subclasses), default/package-private (same package), private (same class only).

Java runs on the JVM using bytecode for cross-platform execution. Master basic syntax including types, variables, control structures, and arrays. Organize code with packages and control visibility using access modifiers.

### Object-Oriented Programming
- Classes
   - Blueprints or templates that define the structure and behavior of objects. Contain fields (data) and methods (functions). Use PascalCase naming convention.
- Objects
   - Instances of classes created using the `new` keyword. Each object has its own state (field values) and can invoke methods. Objects are reference types in Java.
- Constructors
   - Special methods that initialize objects when created. Must have the same name as the class. Default constructor is provided if none is defined. Use `this()` to call other constructors.
- Encapsulation
   - Data hiding principle that bundles data and methods together. Use private fields with public getter/setter methods. Protects internal state from external modification.
- Inheritance
   - Mechanism where a class (subclass) inherits properties and methods from another class (superclass). Use `extends` keyword. Supports code reuse and "is-a" relationships.
- Polymorphism
   - Ability of objects to take multiple forms. Method overriding (runtime) and method overloading (compile-time). Enables flexible and extensible code design.
- Interfaces
   - Contracts that define what methods a class must implement. Use `implements` keyword. Support multiple inheritance. All methods are public and abstract by default.
- Abstract Classes
   - Classes that cannot be instantiated directly. Can contain both abstract and concrete methods. Use `abstract` keyword. Support single inheritance only.

Design software using classes and objects with proper constructors. Apply OOP principles: encapsulation (data hiding), inheritance (code reuse), and polymorphism (flexible behavior). Understand when to use interfaces versus abstract classes.

### Strings
- String Immutability
   - Strings cannot be changed after creation. Any modification creates a new String object. Ensures thread-safety and prevents accidental modifications. Example: `String s = "Hello"; s += " World";` creates a new object.
- String Pooling
   - JVM maintains a pool of unique string literals to save memory. String literals with same content share the same memory location. Use `intern()` method to add strings to pool. Example: `"Hello" == "Hello"` returns true.
- StringBuilder
   - Mutable sequence of characters for efficient string building. Not thread-safe but faster than StringBuffer. Use for single-threaded string concatenation. Example: `StringBuilder sb = new StringBuilder(); sb.append("Hello").append(" World");`
- StringBuffer
   - Thread-safe mutable sequence of characters. Synchronized methods ensure thread safety but slower than StringBuilder. Use for multi-threaded string operations. Example: `StringBuffer sb = new StringBuffer(); sb.append("Hello").append(" World");`
- Common APIs
   - `substring(int start, int end)`: Extract portion of string. `split(String regex)`: Split string into array. `replace(String old, String new)`: Replace occurrences. `format(String format, Object... args)`: Format string with placeholders. Example: `String.format("Hello %s, you are %d years old", "John", 25);`

Strings are immutable and pooled for memory efficiency. Use StringBuilder for efficient concatenation. Master essential APIs like substring, split, replace, and format.

### Exceptions and Error Handling
- Checked Exceptions
   - Exceptions that must be handled at compile time. Compiler forces you to either catch or declare in method signature using `throws`. Examples: IOException, SQLException, ClassNotFoundException. Must be handled or propagated.
- Unchecked Exceptions
   - Runtime exceptions that don't need to be declared or caught. Extend RuntimeException. Examples: NullPointerException, ArrayIndexOutOfBoundsException, IllegalArgumentException. Can be caught but not required.
- try/catch/finally
   - `try` block contains code that might throw exceptions. `catch` blocks handle specific exception types. `finally` block always executes regardless of exceptions. Use for cleanup operations. Example: `try { riskyCode(); } catch (Exception e) { handle(e); } finally { cleanup(); }`
- try-with-resources
   - Automatic resource management for classes implementing AutoCloseable. Resources are automatically closed even if exceptions occur. Introduced in Java 7. Example: `try (FileInputStream fis = new FileInputStream("file.txt")) { /* use fis */ }`
- Custom Exceptions
   - User-defined exception classes extending Exception or RuntimeException. Should include meaningful constructors and messages. Use for domain-specific error conditions. Example: `class CustomException extends Exception { public CustomException(String message) { super(message); } }`

Distinguish between checked exceptions (must handle) and unchecked exceptions (runtime errors). Use try/catch/finally and try-with-resources for proper resource management. Create custom exceptions with meaningful context.

### Generics
- Type Parameters
   - Placeholder types that make classes, interfaces, and methods type-safe. Declared in angle brackets `<T>`. Can be used for any type. Example: `List<String> list = new ArrayList<>();` or `public class Box<T> { private T item; }`
- Bounds
   - Constraints on type parameters to restrict what types can be used. `extends` keyword for upper bounds. Example: `public class NumberBox<T extends Number>` means T must be Number or its subclass. Multiple bounds: `T extends Number & Comparable<T>`
- Wildcards ? extends
   - Upper bounded wildcard for covariance. Accepts the specified type and its subclasses. Read-only access. Example: `List<? extends Number>` can hold List<Integer>, List<Double>, etc. Cannot add elements (except null).
- Wildcards ? super
   - Lower bounded wildcard for contravariance. Accepts the specified type and its superclasses. Write access allowed. Example: `List<? super Integer>` can hold List<Integer>, List<Number>, List<Object>. Can add Integer and its subclasses.
- Type Erasure. 
   - Process where generic type information is removed at compile time. All generic types become Object or their upper bound.Enables backward compatibility but limits runtime type checking. Example: `List<String>` becomes `List` at runtime.

Generics provide compile-time type safety through type parameters and bounds. Use wildcards for flexible type relationships. Understand type erasure limitations at runtime.

### Collections Framework
- Core Interfaces
  - **Collection**: Root interface for all collections. Defines basic operations: add, remove, contains, size, iterator. Example: `Collection<String> coll = new ArrayList<>();`
  - **List**: Ordered collection allowing duplicates. Index-based access. Examples: ArrayList, LinkedList, Vector. Example: `List<String> list = new ArrayList<>(); list.get(0);`
  - **Set**: Collection with no duplicates. No index-based access. Examples: HashSet, LinkedHashSet, TreeSet. Example: `Set<String> set = new HashSet<>(); set.add("item");`
  - **Map**: Key-value pairs, no duplicate keys. Examples: HashMap, LinkedHashMap, TreeMap. Example: `Map<String, Integer> map = new HashMap<>(); map.put("key", 1);`
- Key Implementations
  - **ArrayList**: Resizable array, fast random access, slow insertion/deletion. O(1) get, O(n) add/remove. Example: `List<String> list = new ArrayList<>();`
  - **LinkedList**: Doubly-linked list, fast insertion/deletion, slow random access. O(n) get, O(1) add/remove. Example: `List<String> list = new LinkedList<>();`
  - **HashMap**: Hash table, O(1) average case, no ordering. Example: `Map<String, Integer> map = new HashMap<>();`
  - **TreeMap**: Red-black tree, O(log n) operations, sorted by keys. Example: `Map<String, Integer> map = new TreeMap<>();`
- equals() Contract
  - Reflexive: `x.equals(x)` must be true. Symmetric: `x.equals(y)` iff `y.equals(x)`. Transitive: if `x.equals(y)` and `y.equals(z)`, then `x.equals(z)`. Consistent: multiple calls return same result. Non-null: `x.equals(null)` returns false.
- hashCode() Contract
  - If two objects are equal according to equals(), they must have same hashCode(). If objects have same hashCode(), they may or may not be equal. Must be consistent across multiple calls. Example: `public int hashCode() { return Objects.hash(name, age); }`

Use Collection, List, Set, and Map interfaces with appropriate implementations. Choose based on performance characteristics and ordering needs. Always implement equals/hashCode correctly.

### Date and Time (java.time)
- LocalDate
   - Represents a date without time or timezone (year-month-day). Immutable and thread-safe. Methods: now(), of(), parse(), plusDays(), minusMonths(). Example: `LocalDate today = LocalDate.now(); LocalDate birthday = LocalDate.of(1990, 5, 15);`
- LocalTime
   - Represents time without date or timezone (hour-minute-second-nanosecond). Immutable and thread-safe. Methods: now(), of(), parse(), plusHours(), minusMinutes(). Example: `LocalTime now = LocalTime.now(); LocalTime meeting = LocalTime.of(14, 30);`
- LocalDateTime
   - Combines LocalDate and LocalTime without timezone information. Immutable and thread-safe. Methods: now(), of(), parse(), plusDays(), minusHours(). Example: `LocalDateTime now = LocalDateTime.now(); LocalDateTime event = LocalDateTime.of(2024, 12, 25, 10, 30);`
- Instant
   - Represents a point in time on the UTC timeline. Used for timestamps and logging. Methods: now(), ofEpochSecond(), toEpochMilli(). Example: `Instant now = Instant.now(); long timestamp = now.toEpochMilli();`
- ZoneId
   - Represents a timezone identifier. Use with ZonedDateTime for timezone-aware operations. Common zones: "UTC", "America/New_York", "Europe/London". Example: `ZoneId zone = ZoneId.of("America/New_York"); ZonedDateTime zoned = LocalDateTime.now().atZone(zone);`
- DateTimeFormatter
   - Formats and parses date-time objects. Predefined patterns: ISO_LOCAL_DATE, ISO_LOCAL_TIME. Custom patterns: "yyyy-MM-dd HH:mm:ss". Example: `DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy"); String formatted = date.format(formatter);`

Use immutable java.time types instead of legacy Date/Calendar. Handle time zones properly with ZoneId. Format and parse dates with DateTimeFormatter.

### I/O and NIO.2
- java.io Streams
   - Byte-oriented streams for binary data. InputStream/OutputStream are abstract base classes. Examples: FileInputStream, FileOutputStream, BufferedInputStream. Example: `FileInputStream fis = new FileInputStream("file.txt"); int data = fis.read();`
- Readers
   - Character-oriented streams for text data. Reader/Writer are abstract base classes. Examples: FileReader, BufferedReader, StringReader. Example: `BufferedReader reader = new BufferedReader(new FileReader("file.txt")); String line = reader.readLine();`
- Writers
   - Character-oriented streams for writing text data. Examples: FileWriter, BufferedWriter, PrintWriter. Example: `BufferedWriter writer = new BufferedWriter(new FileWriter("file.txt")); writer.write("Hello World");`
- java.nio.file Paths
   - Modern way to represent file/directory paths. Path interface is platform-independent. Methods: get(), resolve(), normalize(), toAbsolutePath(). Example: `Path path = Paths.get("folder", "file.txt"); Path absolute = path.toAbsolutePath();`
- java.nio.file Files
   - Utility class for file operations. Methods: exists(), createFile(), delete(), copy(), move(), readAllLines(), write(). Example: `Files.copy(source, destination); List<String> lines = Files.readAllLines(path);`
- try-with-resources
   - Automatic resource management for AutoCloseable resources. Resources are closed automatically even if exceptions occur. Introduced in Java 7. Example: `try (FileInputStream fis = new FileInputStream("file.txt")) { /* use fis */ }`

Use java.io for basic I/O operations with proper resource management. Prefer java.nio.file for modern file operations. Always use try-with-resources for automatic cleanup.

### Concurrency
- Threads
   - Lightweight processes that run concurrently. Create with Thread class or Runnable interface. Methods: start(), run(), sleep(), join(). Example: `Thread thread = new Thread(() -> System.out.println("Hello")); thread.start();`
- Executors
   - Framework for managing thread pools and asynchronous execution. ExecutorService interface provides lifecycle management. Examples: newFixedThreadPool(), newCachedThreadPool(), newSingleThreadExecutor(). Example: `ExecutorService executor = Executors.newFixedThreadPool(4);`
- Runnable/Callable
   - Runnable: Interface for tasks that don't return values. Single method: run(). Callable: Interface for tasks that return values. Single method: call() throws Exception. Example: `Callable<String> task = () -> "Result"; Future<String> future = executor.submit(task);`
- Synchronization
   - Mechanism to control access to shared resources. Use synchronized keyword on methods or blocks. Ensures only one thread can access synchronized code at a time. Example: `synchronized(this) { sharedResource++; }`
- volatile
   - Keyword that ensures variable visibility across threads. Prevents compiler optimizations that could cause visibility issues. Doesn't provide atomicity. Example: `private volatile boolean flag = false;`
- atomics
   - Thread-safe classes for atomic operations. Examples: AtomicInteger, AtomicLong, AtomicReference. Provide compare-and-swap operations. Example: `AtomicInteger counter = new AtomicInteger(0); counter.incrementAndGet();`
- CompletableFuture
   - Asynchronous programming with composable futures. Methods: supplyAsync(), thenApply(), thenCompose(), thenCombine(). Handles exceptions and cancellation. Example: `CompletableFuture.supplyAsync(() -> "Hello").thenApply(s -> s + " World");`

Create and manage threads using Executors. Ensure thread-safety with synchronization, volatile, and atomic classes. Compose asynchronous operations with CompletableFuture.

### JVM Internals and Performance
- Memory Model
   - **Heap**: Runtime data area for objects and arrays. Divided into Young Generation (Eden, Survivor spaces) and Old Generation. Shared among all threads. Example: `Object obj = new Object(); // stored in heap`
   - **Stack**: Thread-specific memory for method calls, local variables, and return addresses. Each thread has its own stack. LIFO structure. Example: `int localVar = 10; // stored in stack`
   - **Metaspace**: Memory area for class metadata (Java 8+). Replaces PermGen. Stores class definitions, method bytecode, constant pool. Example: `Class<?> clazz = MyClass.class; // metadata in metaspace`
- Garbage Collection
   - Automatic memory management that reclaims unused objects. Algorithms: Serial, Parallel, CMS, G1, ZGC, Shenandoah. Young GC (frequent, fast) vs Full GC (infrequent, slow). Example: `System.gc(); // suggests GC (not guaranteed)`
- Profiling Tools
   - **JFR (Java Flight Recorder)**: Low-overhead profiling built into JVM. Records events, performance metrics, and memory usage. Example: `java -XX:+FlightRecorder -XX:StartFlightRecording=duration=60s,filename=profile.jfr MyApp`
   - **VisualVM**: GUI tool for monitoring and profiling. Shows memory usage, thread activity, CPU usage. Example: `jvisualvm` command to launch GUI
   - **jcmd, jmap, jstack**: Command-line tools for diagnostics. jcmd for general commands, jmap for heap dumps, jstack for thread dumps. Example: `jcmd <pid> GC.run_finalization`

Understand JVM memory organization and garbage collection algorithms. Profile applications using JFR, VisualVM, or async-profiler. Monitor performance with jcmd, jmap, jstack.

### Reflection, Annotations, SPI
- java.lang.reflect
   - Runtime inspection and manipulation of classes, methods, fields. Classes: Class, Method, Field, Constructor. Methods: getDeclaredMethods(), getField(), invoke(). Example: `Class<?> clazz = MyClass.class; Method method = clazz.getDeclaredMethod("methodName", String.class); method.invoke(instance, "arg");`
- Custom Annotations
   - User-defined metadata for classes, methods, fields. Define with @interface. Use @Retention, @Target, @Documented. Example: `@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface MyAnnotation { String value() default ""; }`
- ServiceLoader
   - Pluggable architecture for loading service implementations. Create META-INF/services/interfaceName file. Load implementations dynamically. Example: `ServiceLoader<MyService> loader = ServiceLoader.load(MyService.class); for (MyService service : loader) { service.doSomething(); }`

Use reflection for runtime inspection and dynamic invocation. Create custom annotations with proper retention and targets. Implement pluggable architectures with ServiceLoader.

### Modules (Java 9+)
- module-info.java
   - Module descriptor file that defines module boundaries and dependencies. Contains module name, exports, requires, provides, uses clauses. Example: `module com.example.app { requires java.base; exports com.example.api; }`
- exports/requires
   - **exports**: Makes packages available to other modules. **requires**: Declares dependency on another module. Control module boundaries and encapsulation. Example: `exports com.example.api; requires java.sql;`
- Migration from classpath
   - Transition from classpath-based to module-path-based applications. Identify dependencies, create module-info.java files, handle split packages. Use --module-path instead of -cp. Example: `java --module-path mods --module com.example.app/com.example.Main`

Organize code into modules with module-info.java. Control module boundaries with exports and requires. Plan migration from classpath to module-path carefully.

### Networking
- Sockets
   - Low-level network communication using TCP/UDP. ServerSocket for servers, Socket for clients. Example: `ServerSocket server = new ServerSocket(8080); Socket client = server.accept();`
- URL/HttpURLConnection
   - Basic HTTP client for simple requests. Synchronous, blocking operations. Example: `URL url = new URL("http://example.com"); HttpURLConnection conn = (HttpURLConnection) url.openConnection();`
- java.net.http.HttpClient
   - Modern HTTP client (Java 11+). Supports HTTP/2, async operations, timeouts. Example: `HttpClient client = HttpClient.newHttpClient(); HttpRequest request = HttpRequest.newBuilder().uri(URI.create("http://example.com")).build();`
- Error handling and timeouts
   - Implement proper exception handling for network operations. Set timeouts to prevent hanging. Use retry logic for transient failures. Example: `request.timeout(Duration.ofSeconds(30));`

Use sockets for low-level networking. Prefer HttpClient for HTTP operations with proper error handling. Implement timeouts and retry logic.

### Security Basics
- JCA/JCE (hashing, encryption)
   - Java Cryptography Architecture for hashing, encryption, digital signatures. Classes: MessageDigest, Cipher, Signature. Example: `MessageDigest md = MessageDigest.getInstance("SHA-256"); byte[] hash = md.digest(data);`
- KeyStore, SSL/TLS
   - **KeyStore**: Secure storage for cryptographic keys and certificates. **SSL/TLS**: Secure communication protocols. Example: `KeyStore ks = KeyStore.getInstance("JKS"); SSLContext sslContext = SSLContext.getInstance("TLS");`
- SecureRandom
   - Cryptographically secure random number generator. Use for generating keys, salts, nonces. Example: `SecureRandom random = new SecureRandom(); byte[] salt = new byte[16]; random.nextBytes(salt);`

Use Java Cryptography Architecture for hashing and encryption. Manage keys with KeyStore and secure communications with TLS. Use SecureRandom for cryptographic operations.

### Database Access (JDBC)
- Connection, Statement, ResultSet
   - **Connection**: Database connection. **Statement**: SQL execution. **ResultSet**: Query results. Example: `Connection conn = DriverManager.getConnection(url); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery("SELECT * FROM users");`
- Connection pooling
   - Reuse database connections for better performance. Libraries: HikariCP, Apache DBCP. Example: `HikariConfig config = new HikariConfig(); config.setJdbcUrl("jdbc:mysql://localhost/db"); HikariDataSource ds = new HikariDataSource(config);`
- SQL injection prevention
   - Use PreparedStatement with parameterized queries. Never concatenate user input into SQL strings. Example: `PreparedStatement ps = conn.prepareStatement("SELECT * FROM users WHERE id = ?"); ps.setInt(1, userId);`

Access databases using JDBC with proper resource management. Use connection pools like HikariCP for performance. Prevent SQL injection with PreparedStatement.

### JSON/XML
- Jackson, Gson for JSON
   - **Jackson**: High-performance JSON library with streaming and tree models. **Gson**: Google's JSON library with simple API. Example: `ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(object);`
- DOM, SAX, StAX for XML
   - **DOM**: In-memory tree representation. **SAX**: Event-driven parsing. **StAX**: Pull-parsing API. Choose based on memory and performance needs. Example: `DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); Document doc = factory.newDocumentBuilder().parse(file);`
- Serialization best practices
   - Handle null values, circular references, and type information. Use annotations for customization. Consider performance implications. Example: `@JsonIgnore private String password; @JsonProperty("user_id") private Long userId;`

Use Jackson or Gson for JSON processing. Choose appropriate XML parsing model (DOM/SAX/StAX). Handle serialization edge cases properly.

### Logging
- slf4j facade
   - Simple Logging Facade for Java. Provides abstraction over logging implementations. Example: `Logger logger = LoggerFactory.getLogger(MyClass.class); logger.info("Application started");`
- Logback, Log4j2
   - **Logback**: Successor to Log4j, faster and more flexible. **Log4j2**: High-performance logging with async capabilities. Example: `logback.xml` configuration file.
- Structured logging
   - Use consistent format with key-value pairs. Include correlation IDs, timestamps, log levels. Example: `logger.info("User login: userId={}, timestamp={}", userId, Instant.now());`

Use slf4j as a logging facade with Logback or Log4j2 backend. Implement structured logging with MDC for correlation. Avoid logging sensitive information.

### Internationalization (i18n/l10n)
- ResourceBundle
   - Mechanism for loading locale-specific resources. Properties files with locale suffixes. Example: `ResourceBundle bundle = ResourceBundle.getBundle("messages", Locale.FRENCH); String message = bundle.getString("welcome");`
- Locale-aware formatting
   - Format dates, numbers, currency according to user's locale. Use NumberFormat, DateFormat, DecimalFormat. Example: `NumberFormat nf = NumberFormat.getCurrencyInstance(Locale.US); String price = nf.format(19.99);`
- Message localization
   - Externalize user-facing strings to properties files. Support pluralization and parameter substitution. Example: `messages.properties: welcome=Welcome {0}! messages_fr.properties: welcome=Bienvenue {0}!`

Localize applications using ResourceBundle and Locale. Format dates, numbers, and currency per user locale. Support pluralization and right-to-left languages.

### Testing
- JUnit 5
   - Modern testing framework with annotations: @Test, @BeforeEach, @AfterEach, @ParameterizedTest. Example: `@Test void testMethod() { assertEquals(expected, actual); }`
- Mockito for mocking
   - Mocking framework for creating test doubles. Annotations: @Mock, @InjectMocks, @Spy. Example: `@Mock private UserService userService; when(userService.findById(1L)).thenReturn(user);`
- Testcontainers for integration tests
   - Integration testing with real databases and services in Docker containers. Example: `@Testcontainers class DatabaseTest { @Container static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13"); }`

Write unit tests with JUnit 5 including parameterized tests. Mock dependencies with Mockito. Use Testcontainers for integration testing with real databases.

### Build and Dependency Management
- Maven, Gradle
   - **Maven**: XML-based build tool with lifecycle phases. **Gradle**: Groovy/Kotlin DSL with incremental builds. Example: `pom.xml` for Maven, `build.gradle` for Gradle.
- Dependency scopes
   - **compile**: Default scope, available in all phases. **test**: Only for testing. **provided**: Provided by runtime. **runtime**: Not needed for compilation. Example: `<scope>test</scope>`
- Multi-module projects
   - Organize large projects into multiple modules. Parent-child relationships, dependency management. Example: `parent/pom.xml` with `<modules>` section.

Use Maven or Gradle for build automation and dependency management. Understand dependency scopes and version alignment. Structure multi-module projects effectively.

### Coding Practices
- Immutability
   - Create objects that cannot be modified after creation. Use final fields, defensive copying. Example: `public final class Person { private final String name; private final int age; }`
- equals/hashCode/compareTo
   - Implement these methods consistently. Use Objects.equals(), Objects.hash(). Example: `public boolean equals(Object obj) { if (this == obj) return true; if (!(obj instanceof Person)) return false; Person other = (Person) obj; return Objects.equals(name, other.name); }`
- API design
   - Design clear, consistent, and intuitive APIs. Use meaningful names, proper error handling, documentation. Example: `public Optional<User> findUserById(Long id) throws IllegalArgumentException { if (id == null) throw new IllegalArgumentException("ID cannot be null"); return userRepository.findById(id); }`

Favor immutable objects and defensive copying. Implement equals/hashCode/compareTo correctly. Design clear, consistent APIs with proper error handling.

### Language Features by Version
- var, switch expressions, text blocks
   - **var**: Local variable type inference (Java 10). **switch expressions**: Expression-based switch (Java 14). **text blocks**: Multi-line strings (Java 15). Example: `var list = new ArrayList<String>(); String result = switch (day) { case MONDAY -> "Start of week"; default -> "Other day"; };`
- records, sealed classes
   - **records**: Data classes with automatic equals/hashCode/toString (Java 16). **sealed classes**: Restricted inheritance (Java 17). Example: `public record Person(String name, int age) {} public sealed class Shape permits Circle, Rectangle {}`
- Pattern matching
   - Enhanced instanceof with pattern matching (Java 17+). Switch expressions with patterns. Example: `if (obj instanceof String s) { System.out.println(s.toUpperCase()); }`

Adopt modern Java features like var, switch expressions, and text blocks. Use records for data classes and sealed classes for controlled inheritance. Apply pattern matching where appropriate.

### Design Patterns
- Creational (Factory, Builder)
   - **Factory**: Create objects without specifying exact classes. **Builder**: Construct complex objects step by step. Example: `public class UserBuilder { private String name; public UserBuilder name(String name) { this.name = name; return this; } public User build() { return new User(name); } }`
- Structural (Adapter, Decorator)
   - **Adapter**: Make incompatible interfaces work together. **Decorator**: Add behavior to objects dynamically. Example: `public class LoggingDecorator implements Service { private Service service; public LoggingDecorator(Service service) { this.service = service; } }`
- Behavioral (Strategy, Observer)
   - **Strategy**: Define family of algorithms and make them interchangeable. **Observer**: Define one-to-many dependency between objects. Example: `public interface PaymentStrategy { void pay(double amount); } public class CreditCardPayment implements PaymentStrategy { public void pay(double amount) { /* credit card logic */ } }`

Apply design patterns to solve common problems. Prefer composition over inheritance. Use concurrency patterns safely.

### Hands-on Milestones
- CLI application
   - Build command-line tool with argument parsing, file I/O, error handling. Example: `public static void main(String[] args) { if (args.length == 0) { System.err.println("Usage: java MyApp <input-file>"); return; } }`
- Collections utilities
   - Create utility library with custom collections, algorithms, data structures. Example: `public class CollectionUtils { public static <T> List<T> filter(List<T> list, Predicate<T> predicate) { return list.stream().filter(predicate).collect(Collectors.toList()); } }`
- HTTP client with retries
   - Implement HTTP client with retry logic, timeouts, error handling. Example: `public class HttpClient { public String get(String url) throws IOException { for (int i = 0; i < maxRetries; i++) { try { return doGet(url); } catch (IOException e) { if (i == maxRetries - 1) throw e; Thread.sleep(retryDelay); } } } }`
- JDBC repository
   - Create data access layer with connection pooling, prepared statements, transactions. Example: `public class UserRepository { public User findById(Long id) { try (Connection conn = dataSource.getConnection(); PreparedStatement ps = conn.prepareStatement("SELECT * FROM users WHERE id = ?")) { ps.setLong(1, id); ResultSet rs = ps.executeQuery(); return mapResultSetToUser(rs); } } }`
- Performance profiling
   - Profile application using JFR, identify bottlenecks, optimize performance. Example: `java -XX:+FlightRecorder -XX:StartFlightRecording=duration=60s,filename=profile.jfr MyApp`

Build practical applications: CLI tools, utility libraries, HTTP clients, database repositories. Profile and optimize performance using JFR and GC logs.